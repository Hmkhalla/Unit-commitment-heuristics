reset;
model unit_commitment.mod;
data 10_24_1_w.dat;
option solver cplex;
option eexit -555;
option display_1col 0;
option display_transpose -3;

#param T_U{J}; 					#minimum time the unit j should be on
#param T_D{J}; 					#minimum time the unit j should be off

fix{j in J, t in T} v[j,t]:=0;
#Initial state of units in time t=1
fix{j in J} v[j,1]:=v0[j];


#we start at time 2
#param t:=2;
display v;

param j in J;


param Toff {J};
set T_bad ;
let T_bad := T;	
param tt in T, >=2;
param t3 in T, >=2;
param L;

repeat while 1==1{

	
	for{t in T_bad: t>=2}
	{
		printf "##   Time period %d  ##\n", t;
		repeat while 1==1 {
			let j:=trunc(Uniform(1, card(J)+1));
			if v[j,t]==0 then
	    	break;
		
		}
		printf "Unit %d \n", j;
		let tt:=t;
		repeat while v[j,tt-1]==0 && tt!=2{
			let tt:=tt-1;
			
		}
		let t3:=tt;
		let Toff[j]:=1;
		repeat while v[j,tt+1]==0 {
			let Toff[j]:=Toff[j]+1;
			
			let tt:=tt+1;
			if tt==bar_t then
			break;
		}
		printf "Toff %d \n", Toff[j];
		
		if Toff[j]>T_D[j] then {
			let L:=trunc(Uniform(1, Toff[j]-T_D[j]));
			fix {a in {t3..(t3+L-1)}} v[j,a]:=1;
			
		}
	
	}
	display v;
	solve;
	
	for{l in T}
	{
		#sum{k in J}p[k,l] == D[l] && 
		if sum{k in J}p_max[k,l] >= D[l] + D[l]*R[l] then
		let T_bad := T_bad diff {l}
	}
	display v;
	display T_bad;
	if sum{m in T_bad}m<=1 then
		break;	
	
	

}

display v;